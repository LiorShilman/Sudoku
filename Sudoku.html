<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
	<meta charset="UTF-8">
    <title>××©×—×§ ×¡×•×“×•×§×•</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;700;900&family=Rubik:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
			--primary: #6366f1;
			--primary-light: #818cf8;
			--primary-dark: #4f46e5;
			--accent: #06b6d4;
			--accent-light: #22d3ee;
			--bg-color: #0c0f1a;
			--bg-secondary: #131829;
			--cell-bg: rgba(30, 41, 69, 0.7);
			--cell-given-bg: rgba(51, 65, 95, 0.8);
			--text-color: #e2e8f0;
			--text-muted: #94a3b8;
			--error-color: #f43f5e;
			--error-glow: rgba(244, 63, 94, 0.3);
			--success-color: #10b981;
			--success-glow: rgba(16, 185, 129, 0.3);
			--border-color: rgba(99, 102, 241, 0.2);
			--keyboard-bg: rgba(19, 24, 41, 0.95);
			--selected-bg: rgba(99, 102, 241, 0.35);
			--selected-border: #818cf8;
			--completed-bg: rgba(16, 185, 129, 0.12);
			--grid-line: rgba(148, 163, 184, 0.08);
			--block-line: rgba(99, 102, 241, 0.4);
			--row-col-completed: rgba(16, 185, 129, 0.06);
			--glass: rgba(255, 255, 255, 0.03);
			--glass-border: rgba(255, 255, 255, 0.06);
			--font-heading: 'Rubik', sans-serif;
			--font-body: 'Heebo', sans-serif;
			--radius-sm: 0.5rem;
			--radius-md: 0.75rem;
			--radius-lg: 1rem;
			--radius-xl: 1.25rem;
			--shadow-glow: 0 0 30px rgba(99, 102, 241, 0.15);
			--transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
		}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: var(--font-body);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
			position: relative;
        }

		/* Animated background */
		body::before {
			content: '';
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background:
				radial-gradient(ellipse at 20% 20%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
				radial-gradient(ellipse at 80% 80%, rgba(6, 182, 212, 0.06) 0%, transparent 50%),
				radial-gradient(ellipse at 50% 50%, rgba(139, 92, 246, 0.04) 0%, transparent 70%);
			pointer-events: none;
			z-index: 0;
			animation: bgShift 15s ease-in-out infinite alternate;
		}

		@keyframes bgShift {
			0% { opacity: 0.7; }
			100% { opacity: 1; }
		}

		/* Header area */
		.game-header {
			position: relative;
			z-index: 1;
			text-align: center;
			margin-bottom: 1.25rem;
			width: 100%;
			max-width: 500px;
		}

        h1 {
			font-family: var(--font-heading);
			font-weight: 800;
			font-size: 2.5rem;
			margin-bottom: 0.25rem;
			text-align: center;
			background: linear-gradient(135deg, #818cf8 0%, #6366f1 30%, #06b6d4 70%, #22d3ee 100%);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			letter-spacing: -0.02em;
			filter: drop-shadow(0 0 20px rgba(99, 102, 241, 0.3));
		}

		.subtitle {
			font-family: var(--font-body);
			font-size: 0.85rem;
			color: var(--text-muted);
			letter-spacing: 0.15em;
			font-weight: 300;
		}

		/* Stats bar */
		.stats-bar {
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 1.5rem;
			margin: 0.75rem 0 1rem;
			position: relative;
			z-index: 1;
		}

		.stat-item {
			display: flex;
			align-items: center;
			gap: 0.4rem;
			font-size: 0.85rem;
			color: var(--text-muted);
			font-family: var(--font-heading);
		}

		.stat-item .stat-icon {
			font-size: 1rem;
			opacity: 0.8;
		}

		.stat-item .stat-value {
			color: var(--text-color);
			font-weight: 600;
			font-variant-numeric: tabular-nums;
		}

		.difficulty-badge {
			display: inline-flex;
			align-items: center;
			gap: 0.3rem;
			padding: 0.25rem 0.75rem;
			border-radius: 2rem;
			font-size: 0.75rem;
			font-weight: 600;
			font-family: var(--font-heading);
			text-transform: uppercase;
			letter-spacing: 0.08em;
			border: 1px solid;
		}

		.difficulty-badge.easy {
			color: #34d399;
			border-color: rgba(52, 211, 153, 0.3);
			background: rgba(52, 211, 153, 0.08);
		}

		.difficulty-badge.medium {
			color: #fbbf24;
			border-color: rgba(251, 191, 36, 0.3);
			background: rgba(251, 191, 36, 0.08);
		}

		.difficulty-badge.hard {
			color: #f87171;
			border-color: rgba(248, 113, 113, 0.3);
			background: rgba(248, 113, 113, 0.08);
		}

		/* Controls */
        .controls {
			position: relative;
			z-index: 1;
            margin: 0 0 1.25rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
			width: 100%;
			max-width: 500px;
        }

        button {
			font-family: var(--font-heading);
			font-weight: 600;
			letter-spacing: 0.02em;
            padding: 0.65rem 1.25rem;
            font-size: 0.9rem;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: var(--radius-md);
            transition: all var(--transition);
            outline: none;
            touch-action: manipulation;
			position: relative;
			overflow: hidden;
        }

		button.btn-difficulty {
			background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
			box-shadow: 0 2px 10px rgba(99, 102, 241, 0.25);
		}

		button.btn-difficulty:hover {
			transform: translateY(-1px);
			box-shadow: 0 4px 15px rgba(99, 102, 241, 0.35);
		}

		button.btn-check {
			background: linear-gradient(135deg, var(--accent) 0%, #0891b2 100%);
			box-shadow: 0 2px 10px rgba(6, 182, 212, 0.25);
		}

		button.btn-check:hover {
			transform: translateY(-1px);
			box-shadow: 0 4px 15px rgba(6, 182, 212, 0.35);
		}

        button:active {
            transform: scale(0.96) translateY(0);
        }

		/* Shimmer effect on buttons */
		button::after {
			content: '';
			position: absolute;
			top: -50%;
			left: -50%;
			width: 200%;
			height: 200%;
			background: linear-gradient(
				transparent 0%,
				rgba(255, 255, 255, 0.05) 50%,
				transparent 100%
			);
			transform: rotate(45deg) translateX(-100%);
			transition: transform 0.6s;
		}

		button:hover::after {
			transform: rotate(45deg) translateX(100%);
		}

		/* Board container */
        .board-container {
			position: relative;
			z-index: 1;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
			padding-bottom: 2rem;
        }

		.board-wrapper {
			position: relative;
			border-radius: var(--radius-xl);
			padding: 3px;
			background: linear-gradient(135deg,
				rgba(99, 102, 241, 0.4) 0%,
				rgba(6, 182, 212, 0.2) 50%,
				rgba(139, 92, 246, 0.3) 100%);
			box-shadow:
				var(--shadow-glow),
				0 20px 60px rgba(0, 0, 0, 0.3),
				inset 0 1px 0 rgba(255, 255, 255, 0.05);
		}

		.board {
			position: relative;
			background: var(--bg-secondary);
			border-radius: calc(var(--radius-xl) - 2px);
			padding: 0;
			display: grid;
			grid-template-columns: repeat(9, 1fr);
			gap: 0;
			aspect-ratio: 1;
			overflow: hidden;
		}

		.cell {
			font-family: var(--font-heading);
			font-weight: 600;
			aspect-ratio: 1;
			background: var(--cell-bg);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.4rem;
			transition: all var(--transition);
			user-select: none;
			color: var(--text-color);
			position: relative;
			border-right: 1px solid var(--grid-line);
			border-bottom: 1px solid var(--grid-line);
			cursor: pointer;
			backdrop-filter: blur(10px);
		}

		.cell:hover:not(.given) {
			background: rgba(99, 102, 241, 0.1);
		}

		/* Block separator lines (RTL: col 0 is rightmost) */
		.cell[data-col="3"],
		.cell[data-col="6"] {
			border-right: 2px solid var(--block-line);
		}

		.cell[data-row="2"],
		.cell[data-row="5"] {
			border-bottom: 2px solid var(--block-line);
		}

		.cell[data-col="8"] {
			border-right: none;
		}

		.cell[data-row="8"] {
			border-bottom: none;
		}

		/* First row & first col rounded corners handled by board overflow:hidden */

		.cell.given {
			background: var(--cell-given-bg);
			color: #a5b4fc;
			font-weight: 700;
			cursor: default;
		}

		.cell.given::after {
			content: '';
			position: absolute;
			bottom: 2px;
			left: 50%;
			transform: translateX(-50%);
			width: 4px;
			height: 4px;
			border-radius: 50%;
			background: rgba(165, 180, 252, 0.3);
		}

		.cell.selected {
			background: var(--selected-bg) !important;
			box-shadow: inset 0 0 0 2px var(--selected-border);
			animation: selectPulse 2.5s ease-in-out infinite;
			z-index: 2;
		}

		@keyframes selectPulse {
			0%, 100% { box-shadow: inset 0 0 0 2px var(--selected-border), 0 0 8px rgba(99, 102, 241, 0.2); }
			50% { box-shadow: inset 0 0 0 2.5px var(--selected-border), 0 0 15px rgba(99, 102, 241, 0.3); }
		}

		.cell.same-number {
			background: rgba(99, 102, 241, 0.12) !important;
		}

		.cell.invalid {
			background: var(--error-glow) !important;
			color: var(--error-color);
			animation: shake 0.4s ease;
		}

		@keyframes shake {
			0%, 100% { transform: translateX(0); }
			25% { transform: translateX(-3px); }
			75% { transform: translateX(3px); }
		}

		.cell.row-completed {
			background-color: var(--row-col-completed) !important;
		}

		.cell.col-completed {
			background-color: var(--row-col-completed) !important;
		}

		.cell.row-completed.col-completed {
			background-color: rgba(16, 185, 129, 0.1) !important;
		}

		.cell.selected.row-completed,
		.cell.selected.col-completed {
			background: var(--selected-bg) !important;
		}

		/* Number enter animation */
		@keyframes numberPop {
			0% { transform: scale(0.5); opacity: 0; }
			60% { transform: scale(1.15); }
			100% { transform: scale(1); opacity: 1; }
		}

		.cell.number-entered {
			animation: numberPop 0.3s ease;
		}

		/* Box completion */
        .box-highlight {
            position: absolute;
            pointer-events: none;
            background: transparent;
            transition: background-color 0.4s ease;
        }

        .box-highlight.completed {
            background: var(--completed-bg);
        }

		/* Victory */
		@keyframes victory-pulse {
			0%, 100% {
				box-shadow: 0 0 20px rgba(16, 185, 129, 0.3),
				            0 0 40px rgba(16, 185, 129, 0.1);
			}
			50% {
				box-shadow: 0 0 30px rgba(16, 185, 129, 0.5),
				            0 0 60px rgba(16, 185, 129, 0.2);
			}
		}

		@keyframes cell-victory {
			0% { background-color: var(--cell-bg); }
			50% { background-color: rgba(16, 185, 129, 0.2); }
			100% { background-color: var(--cell-bg); }
		}

		.board-wrapper.completed {
			background: linear-gradient(135deg,
				rgba(16, 185, 129, 0.5) 0%,
				rgba(52, 211, 153, 0.3) 50%,
				rgba(16, 185, 129, 0.4) 100%);
		}

		.board.completed {
			animation: victory-pulse 2s infinite;
		}

		.board.completed .cell {
			animation: cell-victory 2s infinite;
			animation-delay: calc(var(--cell-index) * 0.05s);
		}

		/* Victory overlay */
		.victory-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(12, 15, 26, 0.85);
			backdrop-filter: blur(8px);
			z-index: 2000;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.5s ease;
		}

		.victory-overlay.show {
			opacity: 1;
			pointer-events: auto;
		}

		.victory-card {
			text-align: center;
			padding: 2.5rem 3rem;
			border-radius: var(--radius-xl);
			background: linear-gradient(135deg, rgba(30, 41, 69, 0.95) 0%, rgba(19, 24, 41, 0.95) 100%);
			border: 1px solid rgba(16, 185, 129, 0.3);
			box-shadow: 0 0 40px rgba(16, 185, 129, 0.2),
			            0 20px 60px rgba(0, 0, 0, 0.4);
			transform: scale(0.8);
			transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
			max-width: 90%;
		}

		.victory-overlay.show .victory-card {
			transform: scale(1);
		}

		.victory-card .trophy {
			font-size: 4rem;
			margin-bottom: 1rem;
			display: block;
			animation: trophyBounce 1s ease infinite;
		}

		@keyframes trophyBounce {
			0%, 100% { transform: translateY(0) rotate(0deg); }
			25% { transform: translateY(-8px) rotate(-5deg); }
			75% { transform: translateY(-8px) rotate(5deg); }
		}

		.victory-card h2 {
			font-family: var(--font-heading);
			font-size: 1.75rem;
			font-weight: 700;
			margin-bottom: 0.5rem;
			background: linear-gradient(135deg, #34d399, #10b981);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
		}

		.victory-card p {
			color: var(--text-muted);
			margin-bottom: 1.5rem;
			font-size: 1rem;
		}

		.victory-card .victory-stats {
			display: flex;
			justify-content: center;
			gap: 2rem;
			margin-bottom: 1.5rem;
		}

		.victory-card .victory-stat {
			text-align: center;
		}

		.victory-card .victory-stat-value {
			font-family: var(--font-heading);
			font-size: 1.5rem;
			font-weight: 700;
			color: var(--accent-light);
		}

		.victory-card .victory-stat-label {
			font-size: 0.75rem;
			color: var(--text-muted);
			margin-top: 0.1rem;
		}

		.victory-card button {
			background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
			padding: 0.75rem 2rem;
			font-size: 1rem;
			border-radius: var(--radius-md);
			box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
		}

		/* Toast messages */
        .message {
            position: fixed;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
			font-weight: 500;
            text-align: center;
            z-index: 3000;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            pointer-events: none;
			backdrop-filter: blur(12px);
			border: 1px solid transparent;
        }

        .message.show {
            opacity: 1;
			transform: translateX(-50%) translateY(0);
        }

        .message.error {
            background: rgba(244, 63, 94, 0.15);
			border-color: rgba(244, 63, 94, 0.3);
			color: #fda4af;
        }

        .message.success {
            background: rgba(16, 185, 129, 0.15);
			border-color: rgba(16, 185, 129, 0.3);
			color: #6ee7b7;
        }

		/* Virtual keyboard - inline under board */
        .virtual-keyboard {
			width: 100%;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.35rem;
			margin-top: 0.75rem;
			position: relative;
			z-index: 1;
			opacity: 0;
			transform: translateY(8px);
			transition: opacity 0.3s ease, transform 0.3s ease;
			pointer-events: none;
        }

        .virtual-keyboard.active {
			opacity: 1;
			transform: translateY(0);
			pointer-events: auto;
        }

        .key {
			font-family: var(--font-heading);
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
			font-weight: 600;
            background: rgba(30, 41, 69, 0.5);
			border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            cursor: pointer;
            color: var(--text-color);
            transition: all var(--transition);
			position: relative;
			overflow: hidden;
        }

		.key:hover {
			background: rgba(99, 102, 241, 0.2);
			border-color: rgba(99, 102, 241, 0.4);
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
		}

        .key:active {
            background: var(--primary);
            transform: scale(0.9) translateY(0);
			border-color: var(--primary-light);
			box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
        }

		.key.completed-number {
			opacity: 0.25;
			pointer-events: none;
		}

        .key.delete {
            font-size: 0.9rem;
			color: var(--error-color);
			border-color: rgba(244, 63, 94, 0.15);
			aspect-ratio: 1;
        }

		.key.delete:hover {
			background: rgba(244, 63, 94, 0.15);
			border-color: rgba(244, 63, 94, 0.4);
			box-shadow: 0 4px 12px rgba(244, 63, 94, 0.15);
		}

		.key.delete:active {
			background: var(--error-color);
			color: white;
		}

		/* Confetti canvas */
		#confetti-canvas {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			z-index: 2500;
		}

		/* Progress dots under board */
		.progress-bar {
			display: flex;
			justify-content: center;
			gap: 0.3rem;
			margin-top: 1rem;
			position: relative;
			z-index: 1;
		}

		.progress-segment {
			width: 2rem;
			height: 3px;
			border-radius: 2px;
			background: rgba(255, 255, 255, 0.08);
			transition: all 0.5s ease;
		}

		.progress-segment.filled {
			background: linear-gradient(90deg, var(--primary), var(--accent));
			box-shadow: 0 0 6px rgba(99, 102, 241, 0.3);
		}

        @media (max-width: 600px) {
			h1 {
				font-size: 2rem;
			}

            .cell {
                font-size: 1.1rem;
            }

            .key {
                font-size: 1.1rem;
            }

            button {
                padding: 0.55rem 0.9rem;
                font-size: 0.8rem;
            }

			.stats-bar {
				gap: 1rem;
			}

			.stat-item {
				font-size: 0.75rem;
			}

			.victory-card {
				padding: 2rem 1.5rem;
			}

			.victory-card h2 {
				font-size: 1.4rem;
			}
        }

		@media (max-width: 380px) {
			.cell {
				font-size: 0.95rem;
			}

			.controls {
				gap: 0.35rem;
			}

			button {
				padding: 0.5rem 0.75rem;
				font-size: 0.75rem;
			}
		}
    </style>
</head>
<body>
	<div class="game-header">
		<h1>×¡×•×“×•×§×•</h1>
		<div class="subtitle">××ª×’×¨ ××ª ×”××•×— ×©×œ×š</div>
	</div>

	<div class="stats-bar">
		<div class="stat-item">
			<span class="stat-icon">â±</span>
			<span class="stat-value" id="timer">00:00</span>
		</div>
		<div id="difficulty-display">
			<span class="difficulty-badge easy">×§×œ</span>
		</div>
		<div class="stat-item">
			<span class="stat-icon">âœ</span>
			<span class="stat-value" id="moves-count">0</span>
			<span>××”×œ×›×™×</span>
		</div>
	</div>

    <div class="controls">
        <button class="btn-difficulty" onclick="startGame('easy')">×§×œ</button>
        <button class="btn-difficulty" onclick="startGame('medium')">×‘×™× ×•× ×™</button>
        <button class="btn-difficulty" onclick="startGame('hard')">×§×©×”</button>
        <button class="btn-check" onclick="checkSolution()">×‘×“×•×§ ×¤×ª×¨×•×Ÿ</button>
    </div>
    <div class="message"></div>
    <div class="board-container">
		<div class="board-wrapper">
			<div class="board"></div>
		</div>
		<div class="virtual-keyboard">
			<div class="key" data-value="1">1</div>
			<div class="key" data-value="2">2</div>
			<div class="key" data-value="3">3</div>
			<div class="key" data-value="4">4</div>
			<div class="key" data-value="5">5</div>
			<div class="key" data-value="6">6</div>
			<div class="key" data-value="7">7</div>
			<div class="key" data-value="8">8</div>
			<div class="key" data-value="9">9</div>
			<div class="key delete" data-value="delete">âœ•</div>
		</div>
		<div class="progress-bar" id="progress-bar"></div>
    </div>

	<!-- Victory overlay -->
	<div class="victory-overlay" id="victory-overlay">
		<div class="victory-card">
			<span class="trophy">ğŸ†</span>
			<h2>×›×œ ×”×›×‘×•×“!</h2>
			<p>×¤×ª×¨×ª ××ª ×”×¡×•×“×•×§×• ×‘×”×¦×œ×—×”</p>
			<div class="victory-stats">
				<div class="victory-stat">
					<div class="victory-stat-value" id="victory-time">00:00</div>
					<div class="victory-stat-label">×–××Ÿ</div>
				</div>
				<div class="victory-stat">
					<div class="victory-stat-value" id="victory-moves">0</div>
					<div class="victory-stat-label">××”×œ×›×™×</div>
				</div>
			</div>
			<button onclick="closeVictory()">××©×—×§ ×—×“×©</button>
		</div>
	</div>

	<canvas id="confetti-canvas"></canvas>

    <script>
        let solution = [];
        let puzzle = [];
        let selectedCell = null;
		let moveCount = 0;
		let timerInterval = null;
		let elapsedSeconds = 0;
		let currentDifficulty = 'easy';
		let gameActive = false;

		// Timer functions
		function startTimer() {
			stopTimer();
			elapsedSeconds = 0;
			updateTimerDisplay();
			timerInterval = setInterval(() => {
				elapsedSeconds++;
				updateTimerDisplay();
			}, 1000);
		}

		function stopTimer() {
			if (timerInterval) {
				clearInterval(timerInterval);
				timerInterval = null;
			}
		}

		function updateTimerDisplay() {
			const mins = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
			const secs = (elapsedSeconds % 60).toString().padStart(2, '0');
			document.getElementById('timer').textContent = `${mins}:${secs}`;
		}

		// Move counter
		function incrementMoves() {
			moveCount++;
			document.getElementById('moves-count').textContent = moveCount;
		}

		// Progress bar
		function updateProgress() {
			let filled = 0;
			let total = 0;
			document.querySelectorAll('.cell').forEach(cell => {
				if (!cell.classList.contains('given')) {
					total++;
					if (cell.textContent !== '') {
						filled++;
					}
				}
			});

			const bar = document.getElementById('progress-bar');
			bar.innerHTML = '';
			const segments = 9;
			const filledSegments = total > 0 ? Math.round((filled / total) * segments) : 0;

			for (let i = 0; i < segments; i++) {
				const seg = document.createElement('div');
				seg.className = 'progress-segment' + (i < filledSegments ? ' filled' : '');
				bar.appendChild(seg);
			}
		}

		// Update difficulty display
		function updateDifficultyDisplay(difficulty) {
			const labels = { easy: '×§×œ', medium: '×‘×™× ×•× ×™', hard: '×§×©×”' };
			const display = document.getElementById('difficulty-display');
			display.innerHTML = `<span class="difficulty-badge ${difficulty}">${labels[difficulty]}</span>`;
		}

		// Highlight same numbers
		function highlightSameNumbers(num) {
			document.querySelectorAll('.cell').forEach(cell => {
				cell.classList.remove('same-number');
				if (num && cell.textContent === String(num) && !cell.classList.contains('selected')) {
					cell.classList.add('same-number');
				}
			});
		}

		// Update completed numbers in keyboard
		function updateKeyboardState() {
			for (let n = 1; n <= 9; n++) {
				let count = 0;
				document.querySelectorAll('.cell').forEach(cell => {
					if (cell.textContent === String(n)) count++;
				});
				const key = document.querySelector(`.key[data-value="${n}"]`);
				if (key) {
					key.classList.toggle('completed-number', count >= 9);
				}
			}
		}

		function generateSudoku(difficulty) {
			solution = Array(9).fill().map(() => Array(9).fill(0));
			fillDiagonal();
			solveSudoku(solution);

			puzzle = Array(9).fill().map(() => Array(9).fill(0));

			let cellsToFill;
			let maxPerBox;
			switch(difficulty) {
				case 'easy': cellsToFill = 51; maxPerBox = 7; break;
				case 'medium': cellsToFill = 41; maxPerBox = 6; break;
				case 'hard': cellsToFill = 31; maxPerBox = 5; break;
			}

			// Count how many cells are filled per 3x3 box
			function getBoxCount(r, c) {
				const br = Math.floor(r / 3) * 3;
				const bc = Math.floor(c / 3) * 3;
				let count = 0;
				for (let i = br; i < br + 3; i++) {
					for (let j = bc; j < bc + 3; j++) {
						if (puzzle[i][j] !== 0) count++;
					}
				}
				return count;
			}

			let filledCells = 0;
			let attempts = 0;
			while (filledCells < cellsToFill && attempts < 5000) {
				let row = Math.floor(Math.random() * 9);
				let col = Math.floor(Math.random() * 9);
				attempts++;
				if (puzzle[row][col] === 0 && getBoxCount(row, col) < maxPerBox) {
					puzzle[row][col] = solution[row][col];
					filledCells++;
				}
			}
		}

        function fillDiagonal() {
            for (let i = 0; i < 9; i += 3) {
                let nums = [1,2,3,4,5,6,7,8,9];
                for (let row = i; row < i + 3; row++) {
                    for (let col = i; col < i + 3; col++) {
                        let randIndex = Math.floor(Math.random() * nums.length);
                        solution[row][col] = nums[randIndex];
                        nums.splice(randIndex, 1);
                    }
                }
            }
        }

		function updateAllCompletions() {
			for (let row = 0; row < 9; row++) {
				const rowCells = Array.from(document.querySelectorAll(`.cell[data-row="${row}"]`));
				const rowNumbers = new Set();
				const isRowComplete = rowCells.every(cell => {
					const value = parseInt(cell.textContent);
					if (!value || isNaN(value) || value < 1 || value > 9 || rowNumbers.has(value)) return false;
					rowNumbers.add(value);
					return true;
				});
				const shouldMarkRow = isRowComplete && rowNumbers.size === 9;
				rowCells.forEach(cell => cell.classList.toggle('row-completed', shouldMarkRow));
			}

			for (let col = 0; col < 9; col++) {
				const colCells = Array.from(document.querySelectorAll(`.cell[data-col="${col}"]`));
				const colNumbers = new Set();
				const isColComplete = colCells.every(cell => {
					const value = parseInt(cell.textContent);
					if (!value || isNaN(value) || value < 1 || value > 9 || colNumbers.has(value)) return false;
					colNumbers.add(value);
					return true;
				});
				const shouldMarkCol = isColComplete && colNumbers.size === 9;
				colCells.forEach(cell => cell.classList.toggle('col-completed', shouldMarkCol));
			}
		}

        function solveSudoku(board) {
            const empty = findEmpty(board);
            if (!empty) return true;
            const [row, col] = empty;
            for (let num = 1; num <= 9; num++) {
                if (isValid(board, num, row, col)) {
                    board[row][col] = num;
                    if (solveSudoku(board)) return true;
                    board[row][col] = 0;
                }
            }
            return false;
        }

        function findEmpty(board) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) return [row, col];
                }
            }
            return null;
        }

        function isValid(board, num, row, col) {
            for (let x = 0; x < 9; x++) {
                if (board[row][x] === num) return false;
            }
            for (let x = 0; x < 9; x++) {
                if (board[x][col] === num) return false;
            }
            let boxRow = Math.floor(row/3) * 3;
            let boxCol = Math.floor(col/3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[boxRow + i][boxCol + j] === num) return false;
                }
            }
            return true;
        }

        function renderBoard() {
            const board = document.querySelector('.board');
            board.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;

                    if (puzzle[i][j] !== 0) {
                        cell.className += ' given';
                        cell.textContent = puzzle[i][j];
                    } else {
                        cell.addEventListener('click', selectCell);
                    }

                    board.appendChild(cell);
                }
            }

            selectedCell = null;
            document.querySelector('.virtual-keyboard').classList.remove('active');
            updateBoxCompletionStatus();
			updateProgress();
			updateKeyboardState();
        }

		function selectCell(e) {
			if (e.target.classList.contains('given')) return;

			const prevSelected = document.querySelector('.cell.selected');
			if (prevSelected) prevSelected.classList.remove('selected');

			e.target.classList.add('selected');
			selectedCell = e.target;

			// Highlight same numbers
			const val = e.target.textContent;
			highlightSameNumbers(val ? parseInt(val) : null);

			updateAllCompletions();
			document.querySelector('.virtual-keyboard').classList.add('active');
		}

        function isBoxCompleted(boxRow, boxCol) {
            const numbers = new Set();
            let valid = true;
            for (let i = 0; i < 3 && valid; i++) {
                for (let j = 0; j < 3 && valid; j++) {
                    const row = boxRow * 3 + i;
                    const col = boxCol * 3 + j;
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                    const value = cell.textContent;
                    if (!value || value === '') {
                        valid = false;
                    } else {
                        const num = parseInt(value);
                        if (numbers.has(num)) valid = false;
                        else numbers.add(num);
                    }
                }
            }
            return valid && numbers.size === 9;
        }

        function updateBoxCompletionStatus() {
            for (let boxRow = 0; boxRow < 3; boxRow++) {
                for (let boxCol = 0; boxCol < 3; boxCol++) {
                    const cells = [];
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = boxRow * 3 + i;
                            const col = boxCol * 3 + j;
                            cells.push(document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`));
                        }
                    }
                    const isCompleted = isBoxCompleted(boxRow, boxCol);
                    cells.forEach(cell => {
                        if (isCompleted) {
                            cell.style.background = 'var(--completed-bg)';
                        } else {
                            cell.style.background = cell.classList.contains('given') ?
                                'var(--cell-given-bg)' : 'var(--cell-bg)';
                        }
                    });
                }
            }
        }

		function initVirtualKeyboard() {
			const keyboard = document.querySelector('.virtual-keyboard');

			keyboard.addEventListener('click', (e) => {
				const key = e.target.closest('.key');
				if (!key || !selectedCell) return;

				const value = key.dataset.value;

				if (value === 'delete') {
					selectedCell.textContent = '';
					selectedCell.classList.remove('invalid', 'number-entered');
				} else {
					const row = parseInt(selectedCell.dataset.row);
					const col = parseInt(selectedCell.dataset.col);
					const num = parseInt(value);

					let tempBoard = puzzle.map(r => [...r]);
					tempBoard[row][col] = num;

					selectedCell.textContent = value;
					selectedCell.classList.remove('number-entered');
					// Force reflow for animation restart
					void selectedCell.offsetWidth;
					selectedCell.classList.add('number-entered');
					selectedCell.classList.toggle('invalid', !isValid(tempBoard, num, row, col));

					incrementMoves();
					highlightSameNumbers(num);
				}

				updateAllCompletions();
				updateBoxCompletionStatus();
				updateProgress();
				updateKeyboardState();
				checkAutoCompletion();
			});
		}

		function checkAutoCompletion() {
			let isComplete = true;
			let isCorrect = true;

			document.querySelectorAll('.cell').forEach(cell => {
				const value = cell.textContent;
				const row = parseInt(cell.dataset.row);
				const col = parseInt(cell.dataset.col);
				if (!value) { isComplete = false; return; }
				if (parseInt(value) !== solution[row][col]) isCorrect = false;
			});

			if (isComplete && isCorrect) {
				checkSolution();
			}
		}

		// Confetti system
		function launchConfetti() {
			const canvas = document.getElementById('confetti-canvas');
			const ctx = canvas.getContext('2d');
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;

			const particles = [];
			const colors = ['#6366f1', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#ec4899', '#8b5cf6', '#22d3ee'];

			for (let i = 0; i < 150; i++) {
				particles.push({
					x: canvas.width / 2 + (Math.random() - 0.5) * 200,
					y: canvas.height / 2,
					vx: (Math.random() - 0.5) * 15,
					vy: (Math.random() - 1) * 15 - 5,
					color: colors[Math.floor(Math.random() * colors.length)],
					size: Math.random() * 8 + 3,
					rotation: Math.random() * 360,
					rotationSpeed: (Math.random() - 0.5) * 10,
					gravity: 0.15,
					opacity: 1,
					decay: 0.005 + Math.random() * 0.01
				});
			}

			function animate() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				let alive = false;

				particles.forEach(p => {
					if (p.opacity <= 0) return;
					alive = true;

					p.x += p.vx;
					p.vy += p.gravity;
					p.y += p.vy;
					p.rotation += p.rotationSpeed;
					p.opacity -= p.decay;
					p.vx *= 0.99;

					ctx.save();
					ctx.translate(p.x, p.y);
					ctx.rotate((p.rotation * Math.PI) / 180);
					ctx.globalAlpha = Math.max(0, p.opacity);
					ctx.fillStyle = p.color;
					ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
					ctx.restore();
				});

				if (alive) requestAnimationFrame(animate);
				else ctx.clearRect(0, 0, canvas.width, canvas.height);
			}

			animate();
		}

		function checkSolution() {
			let isComplete = true;
			let isCorrect = true;

			document.querySelectorAll('.cell').forEach((cell, index) => {
				if (cell.classList.contains('given')) return;
				const row = parseInt(cell.dataset.row);
				const col = parseInt(cell.dataset.col);
				const value = parseInt(cell.textContent);
				cell.style.setProperty('--cell-index', index);
				if (!value) isComplete = false;
				else if (value !== solution[row][col]) isCorrect = false;
			});

			const board = document.querySelector('.board');
			const boardWrapper = document.querySelector('.board-wrapper');
			const message = document.querySelector('.message');
			message.className = 'message';

			if (isComplete && isCorrect) {
				gameActive = false;
				stopTimer();

				board.classList.add('completed');
				boardWrapper.classList.add('completed');

				// Show victory overlay
				const overlay = document.getElementById('victory-overlay');
				document.getElementById('victory-time').textContent = document.getElementById('timer').textContent;
				document.getElementById('victory-moves').textContent = moveCount;
				setTimeout(() => overlay.classList.add('show'), 600);

				launchConfetti();

				message.textContent = '×›×œ ×”×›×‘×•×“! ×¤×ª×¨×ª ××ª ×”×¡×•×“×•×§×• ×‘×”×¦×œ×—×”!';
				message.classList.add('show', 'success');
			} else if (!isComplete) {
				board.classList.remove('completed');
				boardWrapper.classList.remove('completed');
				message.textContent = '× × ×œ××œ× ××ª ×›×œ ×”×ª××™×';
				message.classList.add('show', 'error');
			} else if (!isCorrect) {
				board.classList.remove('completed');
				boardWrapper.classList.remove('completed');
				message.textContent = '×”×¤×ª×¨×•×Ÿ ××™× ×• × ×›×•×Ÿ, × ×¡×” ×©×•×‘';
				message.classList.add('show', 'error');
			}

			setTimeout(() => message.classList.remove('show'), 3000);
		}

		function closeVictory() {
			document.getElementById('victory-overlay').classList.remove('show');
			startGame(currentDifficulty);
		}

		function startGame(difficulty) {
			currentDifficulty = difficulty;
			moveCount = 0;
			document.getElementById('moves-count').textContent = '0';
			gameActive = true;

			generateSudoku(difficulty);
			renderBoard();
			updateDifficultyDisplay(difficulty);
			startTimer();

			document.querySelector('.message').className = 'message';
			document.querySelector('.board').classList.remove('completed');
			document.querySelector('.board-wrapper').classList.remove('completed');
			document.getElementById('victory-overlay').classList.remove('show');
		}

        // Init
        initVirtualKeyboard();
        startGame('easy');

        // Prevent zoom on mobile
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

		// Keyboard support
		document.addEventListener('keydown', (e) => {
			if (!selectedCell) return;
			const num = parseInt(e.key);
			if (num >= 1 && num <= 9) {
				const key = document.querySelector(`.key[data-value="${num}"]`);
				if (key) key.click();
			} else if (e.key === 'Backspace' || e.key === 'Delete') {
				const key = document.querySelector('.key.delete');
				if (key) key.click();
			}
		});

		// Audio context (lazy init on user interaction)
		let audioContext = null;
		function getAudioContext() {
			if (!audioContext) {
				audioContext = new (window.AudioContext || window.webkitAudioContext)();
			}
			return audioContext;
		}

		document.querySelector('.board').addEventListener('click', () => {
			getAudioContext(); // Init on first interaction
		});

		document.querySelector('.virtual-keyboard').addEventListener('click', () => {
			getAudioContext();
		});
    </script>
</body>
</html>

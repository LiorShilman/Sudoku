<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
	<meta charset="UTF-8">
    <title>砖拽 住拽</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;700;900&family=Rubik:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
	
        :root {
			--primary: #4f46e5;
			--primary-hover: #4338ca;
			--bg-color: #0f172a;
			--cell-bg: #1e293b;
			--cell-given-bg: #334155;
			--text-color: #e2e8f0;
			--error-color: #ef4444;
			--success-color: #22c55e;
			--border-color: #475569;
			--keyboard-bg: #1e293b;
			--selected-bg: #3b82f6;
			--completed-bg: rgba(74, 222, 128, 0.15);
			--grid-line: rgba(255, 255, 255, 0.1);
			--block-line: rgba(255, 255, 255, 0.5);
			--selected-bg: rgba(59, 130, 246, 0.5);
			--selected-border: #3b82f6;
			--row-col-completed: rgba(74, 222, 128, 0.05);
			--font-heading: 'Rubik', sans-serif;
			--font-body: 'Heebo', sans-serif;
		}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: var(--font-body);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        h1 {
			font-family: var(--font-heading);
			font-weight: 700;
			font-size: 3rem;
			margin-bottom: 1.5rem;
			text-align: center;
			background: linear-gradient(45deg, var(--primary), #818cf8);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			letter-spacing: -0.02em;
		}

        .controls {
            margin: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
			font-family: var(--font-heading);
			font-weight: 500;
			letter-spacing: 0.02em;
            padding: 0.75rem 1.25rem;
            font-size: 1rem;
            cursor: pointer;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            outline: none;
            touch-action: manipulation;
        }

        button:active {
            transform: scale(0.95);
        }

        .board-container {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            margin-bottom: 140px;
        }

		

		.board {
			position: relative;
			background: var(--border-color);
			border-radius: 1rem;
			padding: 0.5rem;
			display: grid;
			grid-template-columns: repeat(9, 1fr);
			gap: 1px;
			aspect-ratio: 1;
			box-shadow: 0 0 10px rgba(0, 0, 255, 0.2),
                0 0 20px rgba(0, 0, 255, 0.1),
                0 0 30px rgba(0, 0, 255, 0.1);
			animation: neonPulse 2s infinite;
		}

		.cell {
			font-family: var(--font-heading);
			font-weight: 600;
			aspect-ratio: 1;
			background: var(--cell-bg);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.5rem;
			transition: all 0.2s ease;
			user-select: none;
			color: var(--text-color);
			position: relative;
			border-right: 1px solid var(--grid-line);
			border-bottom: 1px solid var(--grid-line);
		}

		@keyframes neonPulse {
			0% {
				box-shadow: 0 0 10px rgba(0, 0, 255, 0.2),
						   0 0 20px rgba(0, 0, 255, 0.1),
						   0 0 30px rgba(0, 0, 255, 0.1);
			}
			50% {
				box-shadow: 0 0 15px rgba(0, 0, 255, 0.3),
						   0 0 25px rgba(0, 0, 255, 0.2),
						   0 0 35px rgba(0, 0, 255, 0.1);
			}
			100% {
				box-shadow: 0 0 10px rgba(0, 0, 255, 0.2),
						   0 0 20px rgba(0, 0, 255, 0.1),
						   0 0 30px rgba(0, 0, 255, 0.1);
			}
		}

		/* 拽 驻专   拽 */
		.cell[data-col="3"],
		.cell[data-col="6"] {
			border-right: 2px solid var(--block-line);
		}

		/* 拽 驻专 驻拽  拽 */
		.cell[data-row="2"],
		.cell[data-row="5"] {
			border-bottom: 2px solid var(--block-line);
		}

		/* 住专转   注 专 */
		.cell[data-col="8"] {
			border-right: none;
		}

		/* 住专转  转转 砖专 专 */
		.cell[data-row="8"] {
			border-bottom: none;
		}

		.cell.row-completed {
			background-color: rgba(74, 222, 128, 0.05) !important;
		}

		.cell.col-completed {
			background-color: rgba(74, 222, 128, 0.05) !important;
		}

		/* 砖专  砖专  注 砖转 */
		.cell.row-completed.col-completed {
			background-color: rgba(74, 222, 128, 0.1) !important;
		}

		/*   砖转 专 转   转专 */
		.cell.selected {
			background: var(--selected-bg) !important;
			box-shadow: inset 0 0 0 2px var(--selected-border);
		}
		
		.cell.given {
			background: var(--cell-given-bg);
			color: #93c5fd;
			font-weight: 700;
		}

		.cell.invalid {
			background: rgba(239, 68, 68, 0.2);
		}

        .box-highlight {
            position: absolute;
            pointer-events: none;
            background: transparent;
            transition: background-color 0.3s ease;
        }

        .box-highlight.completed {
            background: var(--completed-bg);
			color: black !important;
        }
		
		.cell.selected {
			background: var(--selected-bg);
			box-shadow: inset 0 0 0 2px var(--selected-border);
			animation: selectPulse 2s infinite;
		}

		@keyframes selectPulse {
			0% { box-shadow: inset 0 0 0 2px var(--selected-border); }
			50% { box-shadow: inset 0 0 0 3px var(--selected-border); }
			100% { box-shadow: inset 0 0 0 2px var(--selected-border); }
		}

		.cell.row-completed {
			background: var(--row-col-completed);
		}

		.cell.col-completed {
			background: var(--row-col-completed);
		}

		/* 注转 爪转 砖 砖专 注 转 */
		.cell.row-completed.col-completed {
			background: var(--row-col-completed);
			opacity: 0.8;
		}


        .virtual-keyboard {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--keyboard-bg);
            padding: 0.5rem;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(2, auto);
            gap: 0.25rem;
            border-top: 2px solid var(--border-color);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .virtual-keyboard.active {
            transform: translateY(0);
        }

        .key {
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            background: var(--cell-bg);
            border-radius: 0.5rem;
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.2s ease;
        }

        .key:active {
            background: var(--selected-bg);
            transform: scale(0.95);
        }

        .key[data-value="1"],
        .key[data-value="2"],
        .key[data-value="3"],
        .key[data-value="4"],
        .key[data-value="5"] {
            grid-row: 1;
        }

        .key[data-value="6"],
        .key[data-value="7"],
        .key[data-value="8"],
        .key[data-value="9"],
        .key.delete {
            grid-row: 2;
        }

        .key.delete {
            grid-column: 5;
            font-size: 1rem;
        }

        .message {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 1.1rem;
            text-align: center;
            z-index: 1001;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        .message.show {
            opacity: 1;
        }

        .message.error {
            background: var(--error-color);
        }

        .message.success {
            background: var(--success-color);
        }
		
		@keyframes victory-pulse {
			0% {
				transform: scale(1);
				box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7);
			}
			70% {
				transform: scale(1.05);
				box-shadow: 0 0 0 10px rgba(74, 222, 128, 0);
			}
			100% {
				transform: scale(1);
				box-shadow: 0 0 0 0 rgba(74, 222, 128, 0);
			}
		}

		@keyframes cell-victory {
			0% { background-color: var(--cell-bg); }
			50% { background-color: rgba(74, 222, 128, 0.2); }
			100% { background-color: var(--cell-bg); }
		}

		.board.completed {
			animation: victory-pulse 2s infinite;
		}

		.board.completed .cell {
			animation: cell-victory 2s infinite;
			animation-delay: calc(var(--cell-index) * 0.1s);
		}

		.victory-message {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(74, 222, 128, 0.95);
			color: white;
			padding: 2rem;
			border-radius: 1rem;
			font-size: 1.5rem;
			font-weight: bold;
			text-align: center;
			z-index: 1000;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
		}

		.victory-message.show {
			opacity: 1;
		}
	

        @media (max-width: 600px) {
            .board-container {
                margin-bottom: 120px;
            }

            .cell {
                font-size: 1.2rem;
            }

            .key {
                height: 40px;
                font-size: 1.1rem;
            }

            button {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <h1>住拽</h1>
    <div class="controls">
        <button onclick="startGame('easy')">拽</button>
        <button onclick="startGame('medium')"></button>
        <button onclick="startGame('hard')">拽砖</button>
        <button onclick="checkSolution()">拽 驻转专</button>
    </div>
    <div class="message"></div>
    <div class="board-container">
        <div class="board"></div>
    </div>
    <div class="virtual-keyboard">
        <div class="key" data-value="1">1</div>
        <div class="key" data-value="2">2</div>
        <div class="key" data-value="3">3</div>
        <div class="key" data-value="4">4</div>
        <div class="key" data-value="5">5</div>
        <div class="key" data-value="6">6</div>
        <div class="key" data-value="7">7</div>
        <div class="key" data-value="8">8</div>
        <div class="key" data-value="9">9</div>
        <div class="key delete" data-value="delete">拽</div>
    </div>

    <script>
        let solution = [];
        let puzzle = [];
        let selectedCell = null;
		
	
		// 住驻 驻拽爪 拽转 砖 拽转 驻转专
		const originalCheckSolution = checkSolution || function() {};
		checkSolution = function() {
			const result = originalCheckSolution();
			if (result) {
				playSuccessSound();
			} else {
				playErrorSound();
			}
			return result;
		};

		function generateSudoku(difficulty) {
			// 爪专转  专拽
			solution = Array(9).fill().map(() => Array(9).fill(0));
			// 爪专转 驻转专 
			fillDiagonal();
			solveSudoku(solution);
			
			// 爪专转 驻 注  注转拽转 驻转专
			puzzle = Array(9).fill().map(() => Array(9).fill(0));
			
			// 住驻专 转 砖爪专  (驻 住驻专 转 砖住专)
			let cellsToFill;
			switch(difficulty) {
				case 'easy': cellsToFill = 51; break;    // 81 - 30
				case 'medium': cellsToFill = 41; break;  // 81 - 40
				case 'hard': cellsToFill = 31; break;    // 81 - 50
			}
			
			//  专 砖 转 驻转专
			let filledCells = 0;
			while (filledCells < cellsToFill) {
				let row = Math.floor(Math.random() * 9);
				let col = Math.floor(Math.random() * 9);
				if (puzzle[row][col] === 0) {
					puzzle[row][col] = solution[row][col];
					filledCells++;
				}
			}
		}

        function fillDiagonal() {
            for (let i = 0; i < 9; i += 3) {
                let nums = [1,2,3,4,5,6,7,8,9];
                for (let row = i; row < i + 3; row++) {
                    for (let col = i; col < i + 3; col++) {
                        let randIndex = Math.floor(Math.random() * nums.length);
                        solution[row][col] = nums[randIndex];
                        nums.splice(randIndex, 1);
                    }
                }
            }
        }

		function updateAllCompletions() {
			// 拽转 砖专转
			for (let row = 0; row < 9; row++) {
				const rowCells = Array.from(document.querySelectorAll(`.cell[data-row="${row}"]`));
				const rowNumbers = new Set();
				const isRowComplete = rowCells.every(cell => {
					const value = parseInt(cell.textContent);
					if (!value || isNaN(value) || value < 1 || value > 9 || rowNumbers.has(value)) {
						return false;
					}
					rowNumbers.add(value);
					return true;
				});
				
				// 住 专拽  砖 拽 9 住驻专 砖
				const shouldMarkRow = isRowComplete && rowNumbers.size === 9;
				rowCells.forEach(cell => {
					cell.classList.toggle('row-completed', shouldMarkRow);
				});
			}

			// 拽转 注转
			for (let col = 0; col < 9; col++) {
				const colCells = Array.from(document.querySelectorAll(`.cell[data-col="${col}"]`));
				const colNumbers = new Set();
				const isColComplete = colCells.every(cell => {
					const value = parseInt(cell.textContent);
					if (!value || isNaN(value) || value < 1 || value > 9 || colNumbers.has(value)) {
						return false;
					}
					colNumbers.add(value);
					return true;
				});
				
				// 住 专拽  砖 拽 9 住驻专 砖
				const shouldMarkCol = isColComplete && colNumbers.size === 9;
				colCells.forEach(cell => {
					cell.classList.toggle('col-completed', shouldMarkCol);
				});
			}
		}

        function solveSudoku(board) {
            const empty = findEmpty(board);
            if (!empty) return true;
            
            const [row, col] = empty;
            for (let num = 1; num <= 9; num++) {
                if (isValid(board, num, row, col)) {
                    board[row][col] = num;
                    if (solveSudoku(board)) return true;
                    board[row][col] = 0;
                }
            }
            return false;
        }

        function findEmpty(board) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) return [row, col];
                }
            }
            return null;
        }

        function isValid(board, num, row, col) {
            for (let x = 0; x < 9; x++) {
                if (board[row][x] === num) return false;
            }
            
            for (let x = 0; x < 9; x++) {
                if (board[x][col] === num) return false;
            }
            
            let boxRow = Math.floor(row/3) * 3;
            let boxCol = Math.floor(col/3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[boxRow + i][boxCol + j] === num) return false;
                }
            }
            
            return true;
        }

        function renderBoard() {
            const board = document.querySelector('.board');
            board.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    if (puzzle[i][j] !== 0) {
                        cell.className += ' given';
                        cell.textContent = puzzle[i][j];
                    } else {
                        cell.addEventListener('click', selectCell);
                    }
                    
                    board.appendChild(cell);
                }
            }
            
            selectedCell = null;
            document.querySelector('.virtual-keyboard').classList.remove('active');
            document.body.classList.remove('keyboard-active');
            updateBoxCompletionStatus();
        }

        // 注 驻拽爪转 selectCell
		function selectCell(e) {
			if (e.target.classList.contains('given')) return;
			
			const prevSelected = document.querySelector('.cell.selected');
			if (prevSelected) {
				prevSelected.classList.remove('selected');
			}
			
			e.target.classList.add('selected');
			selectedCell = e.target;
			
			// 拽转 砖专转 注转 转  专转 转
			updateAllCompletions();
			
			document.querySelector('.virtual-keyboard').classList.add('active');
			document.body.classList.add('keyboard-active');
		}

        function isBoxCompleted(boxRow, boxCol) {
            const numbers = new Set();
            let isValid = true;
            
            for (let i = 0; i < 3 && isValid; i++) {
                for (let j = 0; j < 3 && isValid; j++) {
                    const row = boxRow * 3 + i;
                    const col = boxCol * 3 + j;
                    const cell = document.querySelector(
                        `.cell[data-row="${row}"][data-col="${col}"]`
                    );
                    
                    const value = cell.textContent;
                    if (!value || value === '') {
                        isValid = false;
                    } else {
                        const num = parseInt(value);
                        if (numbers.has(num)) {
                            isValid = false;
                        } else {
                            numbers.add(num);
                        }
                    }
                }
            }
            
            return isValid && numbers.size === 9;
        }

        function updateBoxCompletionStatus() {
            for (let boxRow = 0; boxRow < 3; boxRow++) {
                for (let boxCol = 0; boxCol < 3; boxCol++) {
                    const cells = [];
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = boxRow * 3 + i;
                            const col = boxCol * 3 + j;
                            cells.push(document.querySelector(
                                `.cell[data-row="${row}"][data-col="${col}"]`
                            ));
                        }
                    }
                    
                                        const isCompleted = isBoxCompleted(boxRow, boxCol);
                    cells.forEach(cell => {
                        if (isCompleted) {
                            cell.style.background = 'var(--completed-bg)';
                        } else {
                            cell.style.background = cell.classList.contains('given') ? 
                                'var(--cell-given-bg)' : 'var(--cell-bg)';
                        }
                    });
                }
            }
        }

        // 注 转 驻拽爪转 initVirtualKeyboard
		function initVirtualKeyboard() {
			const keyboard = document.querySelector('.virtual-keyboard');
			
			keyboard.addEventListener('click', (e) => {
				const key = e.target.closest('.key');
				if (!key || !selectedCell) return;

				const value = key.dataset.value;
				
				if (value === 'delete') {
					selectedCell.textContent = '';
					selectedCell.classList.remove('invalid');
				} else {
					const row = parseInt(selectedCell.dataset.row);
					const col = parseInt(selectedCell.dataset.col);
					const num = parseInt(value);

					let tempBoard = puzzle.map(row => [...row]);
					tempBoard[row][col] = num;

					selectedCell.textContent = value;
					selectedCell.classList.toggle('invalid', !isValid(tempBoard, num, row, col));
				}
				
				// 拽转 砖专转 注转 转 专  砖
				updateAllCompletions();
				updateBoxCompletionStatus();

				// 拽 转  驻转专 砖
				checkAutoCompletion();
			});
		}

		function isRowCompleted(rowIndex) {
			const numbers = new Set();
			let isValid = true;
			
			for (let col = 0; col < 9 && isValid; col++) {
				const cell = document.querySelector(
					`.cell[data-row="${rowIndex}"][data-col="${col}"]`
				);
				const value = cell.textContent;
				
				if (!value || value === '') {
					isValid = false;
				} else {
					const num = parseInt(value);
					if (numbers.has(num)) {
						isValid = false;
					} else {
						numbers.add(num);
					}
				}
			}
			
			return isValid && numbers.size === 9;
		}

		function isColCompleted(colIndex) {
			const numbers = new Set();
			let isValid = true;
			
			for (let row = 0; row < 9 && isValid; row++) {
				const cell = document.querySelector(
					`.cell[data-row="${row}"][data-col="${colIndex}"]`
				);
				const value = cell.textContent;
				
				if (!value || value === '') {
					isValid = false;
				} else {
					const num = parseInt(value);
					if (numbers.has(num)) {
						isValid = false;
					} else {
						numbers.add(num);
					}
				}
			}
			
			return isValid && numbers.size === 9;
		}

		function updateCompletionStatus() {
			// 拽转 砖专转
			for (let row = 0; row < 9; row++) {
				const isCompleted = isRowCompleted(row);
				document.querySelectorAll(`.cell[data-row="${row}"]`).forEach(cell => {
					cell.classList.toggle('row-completed', isCompleted);
				});
			}
			
			// 拽转 注转
			for (let col = 0; col < 9; col++) {
				const isCompleted = isColCompleted(col);
				document.querySelectorAll(`.cell[data-col="${col}"]`).forEach(cell => {
					cell.classList.toggle('col-completed', isCompleted);
				});
			}
			
			// 拽转 转转 3x3 (拽 拽)
			updateBoxCompletionStatus();
		}
		
		// 驻拽爪 砖 拽 转
		function checkAutoCompletion() {
			let isComplete = true;
			let isCorrect = true;
			
			document.querySelectorAll('.cell').forEach((cell, index) => {
				const value = cell.textContent;
				const row = parseInt(cell.dataset.row);
				const col = parseInt(cell.dataset.col);
				
				// 拽  转 专拽
				if (!value) {
					isComplete = false;
					return;
				}
				
				// 拽  注专 
				if (parseInt(value) !== solution[row][col]) {
					isCorrect = false;
				}
			});

			//     - 驻注 转 爪转 住
			if (isComplete && isCorrect) {
				checkSolution(); // 砖砖 驻拽爪 拽转 爪转 爪转 爪
			}
		}


        // 注 转 驻拽爪转 拽
		function checkSolution() {
			let isComplete = true;
			let isCorrect = true;
			
			document.querySelectorAll('.cell').forEach((cell, index) => {
				if (cell.classList.contains('given')) return;
				
				const row = parseInt(cell.dataset.row);
				const col = parseInt(cell.dataset.col);
				const value = parseInt(cell.textContent);
				
				// 住驻转 拽住 爪
				cell.style.setProperty('--cell-index', index);
				
				if (!value) {
					isComplete = false;
				} else if (value !== solution[row][col]) {
					isCorrect = false;
				}
			});

			const board = document.querySelector('.board');
			const message = document.querySelector('.message');
			message.className = 'message';

			// 拽  住拽 砖 爪
			if (isComplete && isCorrect) {
				// 爪转 爪转 爪
				board.classList.add('completed');
				
				// 爪专转 注转 爪   拽转
				let victoryMessage = document.querySelector('.victory-message');
				if (!victoryMessage) {
					victoryMessage = document.createElement('div');
					victoryMessage.className = 'victory-message';
					victoryMessage.textContent = '  ! 驻转专转 转 住拽 爪! ';
					document.body.appendChild(victoryMessage);
				}
				
				// 爪转 注
				setTimeout(() => {
					victoryMessage.classList.add('show');
				}, 500);
				
				// 住转专转 注 专 3 砖转
				setTimeout(() => {
					victoryMessage.classList.remove('show');
				}, 3500);
				
				message.textContent = ' ! 驻转专转 转 住拽 爪! ';
				message.classList.add('show', 'success');
			} else if (!isComplete) {
				board.classList.remove('completed');
				message.textContent = '  转  转!';
				message.classList.add('show', 'error');
			} else if (!isCorrect) {
				board.classList.remove('completed');
				message.textContent = '驻转专  , 住 砖!';
				message.classList.add('show', 'error');
			}
			
			setTimeout(() => {
				message.classList.remove('show');
			}, 3000);
		}

        // 注 转 驻拽爪转 转转 砖拽 砖
		function startGame(difficulty) {
			generateSudoku(difficulty);
			renderBoard();
			document.querySelector('.message').className = 'message';
			document.querySelector('.board').classList.remove('completed');
			
			// 住专转 注转 爪  拽转
			const victoryMessage = document.querySelector('.victory-message');
			if (victoryMessage) {
				victoryMessage.classList.remove('show');
			}
		}

        // 转 砖拽
        initVirtualKeyboard();
        startGame('easy');

        // 注转  
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });
		
		document.addEventListener('DOMContentLoaded', () => {
		// 爪专转 拽拽住 
		const audioContext = new (window.AudioContext || window.webkitAudioContext)();

		// 驻拽爪 爪专转 爪 爪
		function playClickSound() {
			/*const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			
			oscillator.type = 'sine';
			oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
			gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
			
			oscillator.connect(gainNode);
			gainNode.connect(audioContext.destination);
			
			oscillator.start();
			oscillator.stop(audioContext.currentTime + 0.1); */
		}

		// 驻拽爪 爪专转 爪 爪
		function playSuccessSound() {
			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			
			oscillator.type = 'sine';
			oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
			oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.1);
			gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
			
			oscillator.connect(gainNode);
			gainNode.connect(audioContext.destination);
			
			oscillator.start();
			oscillator.stop(audioContext.currentTime + 0.3);
		}

		// 驻拽爪 爪专转 爪 砖
		function playErrorSound() {
			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			
			oscillator.type = 'sine';
			oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
			oscillator.frequency.setValueAtTime(200, audioContext.currentTime + 0.1);
			gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
			
			oscillator.connect(gainNode);
			gainNode.connect(audioContext.destination);
			
			oscillator.start();
			oscillator.stop(audioContext.currentTime + 0.2);
		}

		//  爪转 注 转 
		document.querySelector('.board').addEventListener('click', (event) => {
			const cell = event.target.closest('.cell');
			if (cell) {
				playClickSound();
			}
		});
		
		//  爪转 注 转 
		document.querySelector('.board').addEventListener('click', (event) => {
			const cell = event.target.closest('.cell');
			if (cell) {
				playClickSound();
			}
		});

		//  爪转 注 拽转 专转
		document.querySelector('.virtual-keyboard').addEventListener('click', (event) => {
			const key = event.target.closest('.key');
			if (key) {
				playClickSound();
			}
		});

		//  驻转专 拽转 驻转专
		const checkButton = Array.from(document.querySelectorAll('.controls *'))
			.find(el => el.textContent.trim() === '拽 驻转专');
		
		if (checkButton) {
			checkButton.addEventListener('click', () => {
				// 砖 祝 转 转  注 拽 转转 砖 拽转 驻转专
				const isCorrect = true; 
				
				if (isCorrect) {
					playSuccessSound();
				} else {
					playErrorSound();
				}
			});
		}
	});

    </script>
</body>
</html>